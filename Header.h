#pragma once

// "Динамические структуры данных". Односвязный список

struct DynamicData {	// Объявление динамической структуры
	int Data;		    // Информационное поле
	DynamicData* next;  // Адресное поле, указатель на следующий элемент
};

class List {		               // Объявление списка структуры
	DynamicData* head;			   // Указатель на "голову" списка
	int size;
public:
	List() :head(nullptr), size(0) {};     // Инициализируем конструктор, сводим указатель, обозначающий "голову" в нулевой адрес
	~List();						       // Инициализируем деструктор
	void Add(const int x);				   // Функция для добавления значений в список
	void Show();						   // Функция для отображения списка на экране
	void Pop(const int index);             // Объявим функцию нахождения элемента
	void Remove(const int index);		   // Объявим функцию удаления элемента 
	int Count() { return size; };          // Объявим и определим функцию-счетчик, для нахождения элемента 
};

List::~List() {							// Деструктором будем освобождать выделенную память
	while (head != nullptr)				// Пока "голова" не пустая 
	{
		DynamicData* temp = head->next; // Временная переменная для хранения адреса начала объекта следующего элемента
		delete head;					// Освобождаем адрес "головы"
		head = temp;					// Меняем адрес начала объекта на значение, которое было взято как адрес следующего элемента
	}
}

void List::Add(const int x) {				// Функция добавления элементов в список
	DynamicData* temp = new DynamicData;    // Выделям память. Для этого объявляем локальную переменную *temp, тип которой стуктура,
												//а сама переменная является указателем на структуру
	temp->Data = x;							// Записываем Data  в элемент структуры DynamicData, параметром принятой функции, т.е х
	temp->next = head;                      // Указываем, что следующий элемент - это объект по адресу head. В адресный элемент запишем значение-адрес,
												//которое равняется адресу последнего добавленного
	head = temp;                            // Указываем, что последний активный элемент - это только что введенный
	size++;									// При каждом вызове функции, увеличиваем счетчик. Счетчик нужен, чтобы обращаться к нужному элементу в списке 
}

void List::Show() {                     // Функция отображения списка на экране
	DynamicData* temp = head;           // Определяем указатель, который изначально равен адресу начала списка, то есть "головы"
	while (temp != nullptr)             // Пока временный указатель не пустой:
	{
		std::cout << temp->Data << " "; // Выведет элемент Data из списка List
		temp = temp->next;              // Указываем, что далее нам нужен следующий элемент
	}
}

void List::Pop(const int index){							// В качестве параметра возьмем номер извлекаемого элемента
	DynamicData* temp = head;                               // Будем извлекать элемент с "головы"
	if ((head != nullptr) && (index < size))                // Если адрес не пуст и номер не превышает число его элементов списка, то:
	{
		for (int i = 0; i < index; i++) temp = temp->next;  // Проходим по односвязному списку, переходя по адресам
		std::cout << temp->Data << " " << std::endl;        // Выводим необходимый элемент списка на экран
	}
}
void List::Remove(const int index) {
	DynamicData* prev = head;                               // Будем извлекать элемент с "головы"
	if ((head != nullptr) && (index < size))                // Если адрес не пуст и номер не превышает число его элементов списка, то:
	{
		for (int i = 0; i < index - 1; i++)					// Находим элемент, стоящий ДО удаляемого
		{
			prev = prev->next;
		}
															//[prev] -> [*need-to-delete*] - > [next]
		DynamicData* remove = prev->next;					// Передаем адрес стоящего ПОСЛЕ удаляемого 
		prev->next = remove->next;								//стоящему ДО удаляемого 
		delete remove;										// Очищаем память удаленнного элемента
		size--;						
		Show();
	}
}